import io.franzbecker.gradle.lombok.task.DelombokTask

// without this block gradle seems to download maven metadata for log4j everytime gradle is configuring something
buildscript {
    dependencies {
        constraints {
            //noinspection ForeignDelegate
            classpath('org.apache.logging.log4j:log4j-core') {
                version {
                    strictly('[2.17, 3[')
                    prefer('2.17.0')
                }
                because('CVE-2021-44228, CVE-2021-45046, CVE-2021-45105')
            }
        }
    }
}

plugins {
    id 'io.franzbecker.gradle-lombok' version '5.0.0'
    id 'xyz.wagyourtail.unimined' version '1.1.1' apply false
    id 'com.github.johnrengelman.shadow' version '7.0.0' apply false
    // id "com.dorongold.task-tree" version "2.1.1" to find the dependencies of runClient for the docker file
}

def forgePrjs = [project(':pb-api-forge'), project(':pb-client-forge'), project(':pb-server-forge')]
def fabricPrjs = [project(':pb-api-fabric'), project(':pb-client-fabric'), project(':pb-server-fabric')]
def javaDocPrjs = [project(':pb-api'), project(':pb-api-fabric'), project(':pb-client-fabric'), project(':pb-server-fabric')]
def commonsPrjs = [project(':pb-client'), project(':pb-server')]

def runClientPrjs = fabricPrjs
def platformPrjs = forgePrjs + fabricPrjs
def modPrjs = platformPrjs
def mcProjects = platformPrjs + commonsPrjs + project(':pb-api')
def mixinProjects = mcProjects
def gsonProjects = mcProjects + project(':pb-api')

def clientServerMap = new HashMap<Project, Project>()
clientServerMap[project(':pb-client-forge')] = project(':pb-client')
clientServerMap[project(':pb-server-forge')] = project(':pb-server')
clientServerMap[project(':pb-client-fabric')] = project(':pb-client')
clientServerMap[project(':pb-server-fabric')] = project(':pb-server')

allprojects {
    apply plugin: 'java'
    apply plugin: 'java-library'
    apply plugin: 'idea'
    apply plugin: 'maven-publish'
    apply plugin: 'io.franzbecker.gradle-lombok'

    ext {
        nameNoPb = project.name.split("-").length > 1 ? project.name.split("-")[1] : project.name
        cap_type = nameNoPb.substring(0, 1).toUpperCase() + nameNoPb.substring(1)
        sub_type = cap_type.toLowerCase()
    }

    repositories {
        maven {
            name = 'SpongeMaven'
            url = 'https://repo.spongepowered.org/repository/maven-public/'
        }

        maven {
            name = 'FabricMaven'
            url = 'https://maven.fabricmc.net/'
        }

        maven {
            name = 'JitpackMaven'
            url = 'https://jitpack.io'
        }

        maven {
            name = '3arthMaven'
            url = 'https://3arthqu4ke.github.io/maven'
        }

        maven {
            name = "ParchmentmcMaven"
            url = "https://maven.parchmentmc.net/"
        }

        mavenCentral()
    }

    archivesBaseName = project.name.toLowerCase()
    version = "${project.property('mc_version')}-${project.property('project_version')}"
    group = 'me.earth.pingbypass'
    targetCompatibility = sourceCompatibility = JavaVersion.VERSION_17

    configurations {
        jarLibsApi
        api.extendsFrom jarLibsApi

        jarLibsImplementation
        implementation.extendsFrom jarLibsImplementation

        lwjglAgent
        runtimeOnly.extendsFrom lwjglAgent
    }

    dependencies {
        compileOnly 'org.jetbrains:annotations:24.0.1'

        compileOnly 'org.projectlombok:lombok:1.18.30'
        annotationProcessor 'org.projectlombok:lombok:1.18.30'

        testCompileOnly 'org.projectlombok:lombok:1.18.30'
        testAnnotationProcessor 'org.projectlombok:lombok:1.18.30'

        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.2'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.2'

        if (rootProject.property('hmc.lwjgl').toBoolean()) {
            lwjglAgent "me.earth.headlessmc:headlessmc-lwjgl:1.8.1"
        }
    }

    test {
        useJUnitPlatform()
        testLogging {
            showStandardStreams = true
            events "failed"
            exceptionFormat "full"
        }
    }

    def dependsOnBeforeJavadocAndSourcesJar = new HashSet<>(assemble.dependsOn)

    java {
        withSourcesJar()
        withJavadocJar()
    }

    assemble {
        // I do not want to build the javadocJar every time
        // TODO: better way? dependsOn contains TaskContainers, check each for task?
        dependsOn.removeIf { !dependsOnBeforeJavadocAndSourcesJar.contains(it) }
    }

    // TODO: even though we are doing all of this Intellij still complains about bytecode not matching the source...
    // (actually not if the files are local???)
    if (sourceSets.main.java.srcDirs.stream().anyMatch { it.exists()}) {
        tasks.register('delombok', DelombokTask) {
            dependsOn compileJava
            ext.outputDir = file(buildDir.toPath().resolve('delombok'))
            outputs.dir(ext.outputDir)
            sourceSets.main.java.srcDirs.each {
                if (it.exists()) {
                    inputs.dir(it)
                    // not using -f pretty for now, we might want to use some of these
                    args(it, '-f', 'suppressWarnings:skip',
                             '-f', 'generated:skip',
                             '-f', 'danceAroundIdeChecks:skip',
                             '-f', 'generateDelombokComment:skip',
                             '-f', 'javaLangAsFQN:skip',
                             '-d', ext.outputDir)
                }
            }
        }

        javadoc {
            dependsOn delombok
            source = delombok.outputDir
            options.addStringOption('Xdoclint:none', '-quiet')
            options.linkSource true
        }

        sourcesJar {
            dependsOn delombok
            from delombok.outputDir
            // I tried every single exclude/include pattern but I could not get any to work
            exclude (fileTreeElement -> {
                return !((FileTreeElement) fileTreeElement)
                        .getFile()
                        .toPath()
                        .toAbsolutePath()
                        .startsWith(((File) delombok.outputDir).toPath().toAbsolutePath())
            })
        }
    }

    tasks.withType(JavaCompile).configureEach {
        if (JavaVersion.current().isJava9Compatible()) {
            it.options.release.set(17)
        }
    }

    // This allows Intellij to find ByteCode for our classes after a jar has been built.
    // Helpful for writing the Mixins in pb-security.
    idea {
        module {
            inheritOutputDirs = false
            outputDir = compileJava.destinationDirectory.getAsFile().getOrNull()
            testOutputDir = compileTestJava.destinationDirectory.getAsFile().getOrNull()
        }
    }

    if (gsonProjects.contains(project)) {
        dependencies {
            // TODO: Theoretically it is correct to expose this as api since we expose interfaces using gson classes
            //  But this means that in plugins, to get forge to work in gradle we need to exclude it on every dependency
            api 'com.google.code.gson:gson:2.10.1'
        }
    }

    if (mixinProjects.contains(project)) {
        dependencies {
            compileOnly 'org.spongepowered:mixin:0.8.5'
        }
    }

    if (commonsPrjs.contains(project)) {
        dependencies {
            api project(':pb-api')
        }
    }

    if (javaDocPrjs.contains(project)) {
        configurations {
            javaDocLibs
            compileOnly.extendsFrom javaDocLibs
        }

        afterEvaluate {
            javadoc {
                classpath += files(configurations.javaDocLibs.resolve())
            }

            if (tasks.find { it.name == 'delombok' }) {
                delombok {
                    classpath += files(configurations.javaDocLibs.resolve())
                }
            }
        }
    }

    if ([project(':pb-server-fabric'), project(':pb-server-forge')].contains(project)) {
        dependencies {
            jarLibsApi project(':pb-server')
        }
    }

    if ([project(':pb-client-fabric'), project(':pb-client-forge')].contains(project)) {
        dependencies {
            jarLibsApi project(':pb-client')
        }
    }

    if (mcProjects.contains(project)) {
        apply plugin: 'xyz.wagyourtail.unimined'

        unimined.minecraft(sourceSets.main, true) {
            version rootProject.mc_version

            mappings {
                intermediary()
                mojmap()
                parchment("2024.02.25")
            }

            if (forgePrjs.contains(project)) {
                ext {
                    type = 'forge'
                }

                mappings {
                    devFallbackNamespace "intermediary"
                }

                forge {
                    loader project.forge_version
                    if (modPrjs.contains(project) && project.ext.sub_type != 'api') {
                        mixinConfig += ["mixins.pingbypass_${project.ext.sub_type}.json".toString(), "mixins.pingbypass.json"]
                    } else {
                        mixinConfig += ["mixins.pingbypass.json"]
                    }
                }
            }

            if (fabricPrjs.contains(project)) {
                fabric {
                    loader rootProject.fabric_version
                }
            }
        }

        unimined.minecraft(sourceSets.main) {
            //runs.off = true
            //defaultRemapJar = false
        }

        // otherwise javadocJar and sourcesJar will fail because Minecraft etc. wont be found
        afterEvaluate {
            javadoc {
                classpath += sourceSets.main.compileClasspath
            }

            if (tasks.find { it.name == 'delombok' }) {
                delombok.classpath += sourceSets.main.compileClasspath
            }
        }
    }

    if (platformPrjs.contains(project)) {
        apply plugin: 'com.github.johnrengelman.shadow'

        dependencies {
            jarLibsApi project(':pb-api')

            // Added because Runtime Remapping does not seem to remap methods rn if we just place the jar in the mods folder
            if (rootProject.property('hmc.specifics').toBoolean()) {
                // TODO: make 1.20.4 release for specifics!!!
                // TODO: instead of 1.20.4-1.2.2 use set mc version
                // TODO: Hmc-Specifics: Bad Maven pub leads to lots of warnings about duplicate classes!
                modImplementation "me.earth.headlessmc:hmc-specifics-fabric:1.20.1-1.2.2"
            }
        }

        shadowJar {
            configurations = [project.configurations.jarLibsApi, project.configurations.jarLibsImplementation]
            archiveClassifier.set('fat')
            exclude '**/module-info.class'
            exclude '**/META-INF/maven/'
            exclude '**/com/google/gson/**'
        }

        remapJar {
            dependsOn(shadowJar)
            inputFile.set(shadowJar.archiveFile)
            archiveClassifier.set('release')
            exclude '**/module-info.class'
            exclude '**/META-INF/maven/'
            exclude '**/com/google/gson/**'
        }
    }

    if (runClientPrjs.contains(project)) {
        afterEvaluate {
            runClient {
                standardInput = System.in
                // Without this fix unimined 0.3 adds " around the path, at least on unix, like this:
                // "/home/.../pingbypass/build/unimined/remapClasspath.txt"
                systemProperties['fabric.remapClasspathFile'] = rootProject.buildDir.toPath().resolve("unimined").resolve("remapClasspath.txt").toAbsolutePath()
                //jvmArgs += ['-Dmixin.debug.export=true']
                if (rootProject.property('hmc.lwjgl').toBoolean()) {
                    jvmArgs += ["-javaagent:${configurations.lwjglAgent.files.iterator().next()}"]
                    systemProperties['joml.nounsafe'] = 'true'
                    systemProperties['fabric.systemLibraries'] = "${configurations.lwjglAgent.files.iterator().next()}"
                }
            }
        }

        tasks.register('runClientWithoutDependencies') {
            doLast {
                project['runClient'].exec()
            }
        }
    }

    if (forgePrjs.contains(project)) {
        ext {
            type = 'forge'
        }

        processResources {
            inputs.property "version", project.version

            filesMatching("META-INF/mods.toml") {
                expand "version": rootProject.property('project_version')
            }
        }
        //remapJar {
        //    targetNamespace = MappingNamespace.SEARGE
        //}
    }

    if (fabricPrjs.contains(project)) {
        ext {
            type = 'fabric'
        }

        processResources {
            inputs.property "version", project.version

            filesMatching("fabric.mod.json") {
                expand "version": rootProject.property('project_version')
            }
        }

        //remapJar {
        //    targetNamespace = MappingNamespace.INTERMEDIARY
        //}
    }

    if (modPrjs.contains(project)) {
        jar {
            exclude '**/module-info.class'
            exclude '**/META-INF/maven/'
            exclude '**/com/google/gson/**'
            manifest {
                attributes(
                    'MixinConfigs': project.ext.sub_type == 'api' ? 'mixins.pingbypass.json' : "mixins.pingbypass_${project.ext.sub_type}.json,mixins.pingbypass.json",
                    'MixinConnector': "me.earth.pingbypass.${project.ext.sub_type}.launch.${project.ext.cap_type}MixinConnector",
                    'Implementation-Title': "PingBypass-${project.ext.cap_type}",
                    'Implementation-Version': project.version
                )
            }
        }
    }

    if (clientServerMap.containsKey(project)) {
        processResources {
            inputs.property "version", rootProject.property('project_version')
            filesMatching("pb.pluginconfig.json") {
                expand "version": rootProject.property('project_version')
            }
        }

        // TODO: build pluginJar, which does not contain api!
        // TODO: mod.toml/fabric.json: include multiple mods, like pingbypass,
        //  but not in the plugin jar, there just have a dependency on pingbypass
    }
}

dependencies {
    // makes the pom of the 'pingbypass' maven artifact contain all modules
    api project(':pb-api')
    api project(':pb-client')
    api project(':pb-server')
}

def pubSuffix = System.getenv('IS_MAVEN_PUB') != null
    ? ''
    : System.getenv('GITHUB_RUN_NUMBER') != null && System.getenv('GITHUB_SHA') != null
        ? "-${System.getenv('GITHUB_RUN_NUMBER')}-${System.getenv('GITHUB_SHA').substring(0, 7)}"
        : ''

allprojects {
    if (!project.name.endsWith('forgerunner')) {
        publishing {
            publications {
                "$project.name"(MavenPublication) {
                    ((MavenPublication) it).groupId "${project.group}"
                    ((MavenPublication) it).artifactId "${project.archivesBaseName.toLowerCase()}"
                    ((MavenPublication) it).version "${project.version}${pubSuffix}"
                    //noinspection GroovyAssignabilityCheck
                    from components.java
                }
            }

            repositories {
                // mavenLocal()
                // maven {
                //     name = 'SomewhereOnThisMachine'
                //     url = 'file://...'
                // }

                if (System.getenv("PB_OTHER_REPO") != null) {
                    maven {
                        name = 'otherrepo'
                        url = "${System.getenv("PB_OTHER_REPO")}"
                    }
                }

                if (System.getenv('DEPLOY_TO_GITHUB_PACKAGES_URL') == null) {
                    maven {
                        name = 'BuildDirMaven'
                        url = rootProject.layout.buildDirectory.dir('maven')
                    }
                } else {
                    maven {
                        name = 'GithubPagesMaven'
                        url = System.getenv('DEPLOY_TO_GITHUB_PACKAGES_URL')
                        credentials {
                            username = System.getenv('GITHUB_USER')
                            password = System.getenv('GITHUB_TOKEN')
                        }
                    }
                }
            }
        }

        publish {
            dependsOn(javadocJar)
            dependsOn(sourcesJar)
            dependsOn(build)
        }
    }
}

publish {
    dependsOn(subprojects.build)
    dependsOn(subprojects.publish)
}

subprojects {
    afterEvaluate {
        tasks.withType(GenerateMavenPom).configureEach {
            it.pom.withXml {
                asNode().dependencies.dependency.each { dependency ->
                    // Since mixin is runtime scope and needs an additional repository it might be better to exclude it
                    if (dependency.artifactId.last().value().last() in ['fabric-loader', 'unspecified', 'mixin']) {
                        assert dependency.parent().remove(dependency)
                    }
                }
            }
        }
    }
}

tasks.register('runPBClientFabric') {
    description = 'Runs the PingBypass-Client on Fabric'
    group = 'run'
    dependsOn(project(':pb-client-fabric')['runClient'])
}

tasks.register('runPBServerFabric') {
    description = 'Runs the PingBypass-Server on Fabric'
    group = 'run'
    dependsOn(project(':pb-server-fabric')['runClient'])
}
